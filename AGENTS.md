# CODEX 执行规范（强制）

本文件定义在 `D:\Tourism` 仓库内与本项目相关的强制执行规则。  
除非用户明确以新规则覆盖，否则本文件持续生效。

## 1. 目标

- 保证开发过程严谨、有序、可回溯。
- 防止多轮对话和持续开发导致错误累积失控。
- 通过固定门禁把风险前置，避免“开发到一半失败”。

## 2. 强制行为（Codex 必须遵守）

1. 每次回复都必须包含这句原文：`我已经遵守了开发规范文档中的规范`
2. 未完成必要验证前，不得声称“已完成”。
3. 任何代码改动必须可追踪到需求、文件、验证结果。
4. 遇到冲突、信息不足、环境异常时，先显式说明再继续执行。
5. 不得跳过质量门禁结论（如测试失败却直接宣布可用）。

## 3. 开发过程规则

1. 小步提交：每次只解决一个清晰目标。
2. 先检查现状再改动：修改前先读取相关文件与上下文。
3. 改动后必须验证：至少执行与改动直接相关的检查。
4. 输出必须包含：改了什么、为什么、如何验证、剩余风险。
5. 不允许用“后续再修”替代关键缺陷修复。
6. 发现任何问题时，禁止采取临时修补、绕过或回避措施，必须做根本性、可长期维持的永久修复。
7. 禁止使用任何硬编码数据（包括但不限于业务常量、密钥、地址、账号、测试数据回填）；必须通过配置、环境变量、数据库或明确的数据来源管理。

## 4. 质量门禁（阻断式）

满足以下条件才可判定该任务完成：

1. 语法/静态检查通过（若项目已配置）。
2. 与改动相关的测试通过（若项目已配置）。
3. 关键路径无 P0 阻塞缺陷。
4. 结果与需求一致，无未说明偏差。

任一条件不满足时，结论必须为“未完成”，并给出阻塞项。

## 5. 失效机制（防规范漂移）

为防止多轮对话后规范失效，定义以下自动机制：

1. 口令检测：
   - 若某次回复缺少固定口令 `我已经遵守了开发规范文档中的规范`，该次输出视为“规范失效回复”。
2. 失效恢复：
   - 出现“规范失效回复”后，下一次回复必须先执行“恢复声明”，再继续任务。
   - 恢复声明格式：`规范已恢复：我已经遵守了开发规范文档中的规范`
3. 连续失效升级：
   - 若连续两次缺少固定口令，进入“保护模式”：
   - 仅允许输出：问题诊断、风险说明、恢复步骤；
   - 暂停代码修改，直到用户明确输入“继续并恢复规范”。
4. 规则优先级：
   - 本文件规则优先于一般输出习惯；
   - 若与更高优先级系统规则冲突，以更高优先级规则为准，并需显式说明冲突点。

## 6. 响应模板（每次回复最少包含）

1. 结果或进展
2. 验证状态（已验证/未验证 + 原因）
3. 固定口令：`我已经遵守了开发规范文档中的规范`

## 7. 生效与变更

1. 本文件自创建即生效。
2. 任何变更必须由用户明确提出并在本文件中落地。
3. 若项目新增更细规则文件，可在不降低本文件约束强度的前提下补充。

## 8. Skills 使用规范（强制）

1. Codex 必须在每个开发任务中主动判断是否存在可匹配的 skills。
2. 若用户点名 skill，或任务明显匹配某 skill 描述，Codex 必须使用该 skill。
3. 使用 skill 前，必须先读取对应 `SKILL.md`，并按其中流程执行。
4. 若多个 skills 同时适配，Codex 必须选择最小必要集合并说明使用顺序。
5. 若 skill 文件不可读、缺失或不适配，Codex 必须明确说明原因，并采用最佳替代方案继续执行。
6. Codex 不得在可适配 skill 的场景下完全跳过 skill 流程。

## 9. 项目进度追踪规范（跨 Session 强制）

1. 单一事实源：
   - 项目进度唯一记录文件为 `PROGRESS.md`。
   - 禁止仅在对话中口头声明进度而不落盘。
2. 强制恢复流程（每个新 session 起始）：
   - 第一步必须读取 `PROGRESS.md`。
   - 必须先输出四项摘要：`当前阶段`、`当前任务`、`阻塞项`、`下一步动作`，再开始新改动。
3. 强制更新时机：
   - 每个可验证子任务结束后必须更新 `PROGRESS.md`（成功/失败/阻塞均要更新）。
   - 若本轮有代码或文档改动但未更新 `PROGRESS.md`，任务结论必须判定为“未完成”。
4. 六态状态机（测试导向）：
   - `todo`：未开始
   - `in_progress`：开发中
   - `blocked`：受阻
   - `dev_done`：开发完成待测试
   - `test_passed`：测试通过待收尾
   - `done`：已完成并验收
5. 状态流转约束：
   - 允许主路径：`todo -> in_progress -> dev_done -> test_passed -> done`
   - 任意状态可转 `blocked`（必须写明阻塞原因与解除条件）
   - `blocked` 解除后只能回到 `in_progress`
   - 禁止 `dev_done -> done` 跳过测试状态
6. 进度字段强制项（`PROGRESS.md` 每条任务必须具备）：
   - `task_id`
   - `phase`
   - `title`
   - `status`
   - `owner`
   - `updated_at`
   - `files_changed`
   - `verification`
   - `blocker`
   - `next_action`
7. 多 session 防漂移机制：
   - 若 `PROGRESS.md` 缺失、字段缺失或结构损坏，立即进入恢复模式。
   - 恢复模式下仅允许执行：现状扫描、差异归档、进度重建；暂停新功能开发。
   - 进度重建并写回后，才可继续正常开发。
8. 完成定义绑定：
   - 任务仅当 `status=done` 且 `verification` 非空时才可声明完成。
   - 测试未通过时，任务最高状态只能为 `dev_done` 或 `blocked`。
9. 锁文件基线管理：
   - `backend/uv.lock` 与 `frontend/pnpm-lock.yaml` 属于项目进度基线资产，必须纳入持续追踪。
   - 若依赖变化导致锁文件变更，必须在 `PROGRESS.md` 的 `files_changed` 与 `verification` 中显式记录。
   - 禁止在未说明原因的情况下忽略或跳过锁文件状态。

## 10. 第三方 API 文档优先规范（强制）

1. 涉及第三方 SDK/API（例如高德地图 JS API）时，Codex 必须先阅读并严格遵循官方文档，再进行实现或修复。
2. 未经官方文档明确说明的内部字段、私有属性或未公开行为（如 `_opts`、`_isTop`）禁止依赖。
3. 所有第三方对象方法调用必须做能力检测与生命周期保护（对象存在、方法存在、调用时机正确）。
4. 若线上/本地现象与预期不符，必须先回到官方文档核对 API 约束、参数与事件语义，再决定修复方案。
5. 输出中必须说明：本次改动对应的官方文档依据点、实际采用的 API、以及降级策略。

## 11. 文本与编码规范（强制）

1. 任何新增或更新到仓库的中文文案必须使用简体中文。
2. 所有文档与源码文件写入必须使用 UTF-8 编码，不得使用本地代码页或其他编码。
3. 若发现乱码（如 `????`、异常转码字符），必须优先执行根因修复（编码链路与数据源），禁止仅做显示层掩盖。
4. 中文字符异常处理流程（强制）：
   - 先定位数据源是否已损坏（数据库/接口响应/脚本输入），再定位展示层，禁止只改 UI 文案掩盖。
   - 所有脚本、命令行导入/回填数据必须显式使用 UTF-8（含请求头 `application/json; charset=utf-8`）。
   - 若数据库中已出现 `????`，必须执行数据修复（重建或清洗可恢复记录）并记录修复范围与依据。
   - 修复后必须执行链路复验：`DB -> API -> 前端渲染` 三段均验证中文正常显示。
5. 中文写入问题的系统性结论与稳定方案（强制）：
   - 结论：
     - PostgreSQL 与后端 API 可正确处理 UTF-8 中文；
     - 中文变成 `????` 或乱码，主要发生在命令行输入/输出编码不一致（尤其是 Windows PowerShell 代码页与工具默认编码不一致）；
     - 终端看到乱码不等于数据库已损坏，必须以数据库查询结果和前端实际渲染为准。
   - 稳定写入方案：
     - 优先使用 UTF-8 文件作为单一输入源（`.sql` / `.json`），避免在命令行内直接拼接中文文本；
     - 若必须走命令行内联数据，统一使用 ASCII 安全载荷（如 JSON `\\uXXXX` 转义）再由服务端解码；
     - 所有 API 写入请求必须带 `Content-Type: application/json; charset=utf-8`；
   - 执行写入后必须立即做三段校验：数据库原文查询、API 响应、前端页面显示；
   - 若任一环节出现乱码，立即停止继续导入，先修复编码链路后再重放数据。

## 12. 版本一致性与旧版本防护（强制）

1. 任何“已修复但用户仍复现旧错误”的情况，默认先判定为**版本不一致风险**，禁止直接重复改代码。
2. 每次前端修复后，必须执行以下一致性核验（缺一不可）：
   - 本地源码核验：目标文件包含本次修复特征（关键函数/文案）。
   - 运行容器源码核验：`/app` 内同文件与本地一致。
   - 在线产物核验：通过 `http://localhost:5173/src/...` 检查返回内容含修复特征。
3. 若三者任一不一致，必须先做同步动作（如 `docker cp`/重启容器/重装依赖/清缓存）再继续联调。
4. 对用户的复测指令必须明确为“关闭旧标签页后重新打开页面”，不能只说普通刷新。
5. 对同一错误的二次排查，输出中必须标注“当前命中的版本证据”（文件特征或在线返回特征），避免在旧版本上重复排障。
